<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Secp256k1PublicKey.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">casper-java-sdk</a> &gt; <a href="index.source.html" class="el_package">com.syntifi.crypto.key</a> &gt; <span class="el_source">Secp256k1PublicKey.java</span></div><h1>Secp256k1PublicKey.java</h1><pre class="source lang-java linenums">package com.syntifi.crypto.key;

import com.syntifi.crypto.key.encdec.Hex;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import org.bouncycastle.asn1.*;
import org.web3j.crypto.Hash;
import org.web3j.crypto.Sign;
import org.web3j.crypto.Sign.SignatureData;

import java.io.*;
import java.math.BigInteger;
import java.security.GeneralSecurityException;
import java.util.Arrays;

/**
 * secp256k1 implementation of {@link AbstractPublicKey}
 *
 * @author Alexandre Carvalho
 * @author Andre Bertolace
 * @since 0.1.0
 */
<span class="fc" id="L23">@NoArgsConstructor</span>
<span class="nc bnc" id="L24" title="All 8 branches missed.">@EqualsAndHashCode(callSuper = true)</span>
public class Secp256k1PublicKey extends AbstractPublicKey {

    public Secp256k1PublicKey(final byte[] bytes) {
<span class="fc" id="L28">        super(bytes);</span>
<span class="fc" id="L29">    }</span>

    @Override
    public void loadPublicKey(final byte[] publicKey) throws IOException {
<span class="fc" id="L33">        final ASN1Primitive derKey = ASN1Primitive.fromByteArray(publicKey);</span>
<span class="fc" id="L34">        final ASN1Sequence objBaseSeq = ASN1Sequence.getInstance(derKey);</span>
<span class="fc" id="L35">        final String keyId = ASN1ObjectIdentifier.getInstance(ASN1Sequence.getInstance(objBaseSeq.getObjectAt(0)).getObjectAt(0)).getId();</span>
<span class="fc" id="L36">        final String curveId = ASN1ObjectIdentifier.getInstance(ASN1Sequence.getInstance(objBaseSeq.getObjectAt(0)).getObjectAt(1)).getId();</span>
<span class="pc bpc" id="L37" title="1 of 2 branches missed.">        if (curveId.equals(ASN1Identifiers.Secp256k1OIDCurve.getId())</span>
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">                &amp;&amp; keyId.equals(ASN1Identifiers.Secp256k1OIDkey.getId())) {</span>
<span class="fc" id="L39">            final DERBitString key = DERBitString.getInstance(objBaseSeq.getObjectAt(1));</span>
<span class="fc" id="L40">            setKey(key.getBytes());</span>
<span class="fc" id="L41">        } else {</span>
<span class="nc" id="L42">            throw new IOException();</span>
        }
<span class="fc" id="L44">    }</span>

    @Override
    public void readPublicKey(final Reader reader) throws IOException {
<span class="fc" id="L48">        loadPublicKey(PemFileHelper.readPemFile(reader));</span>
<span class="fc" id="L49">    }</span>

    @Override
    public void writePublicKey(final Writer writer) throws IOException {
<span class="fc" id="L53">        final DERBitString key = new DERBitString(getKey());</span>
<span class="fc" id="L54">        final ASN1EncodableVector v1 = new ASN1EncodableVector();</span>
<span class="fc" id="L55">        v1.add(ASN1Identifiers.Secp256k1OIDkey);</span>
<span class="fc" id="L56">        v1.add(ASN1Identifiers.Secp256k1OIDCurve);</span>
<span class="fc" id="L57">        final DERSequence derPrefix = new DERSequence(v1);</span>
<span class="fc" id="L58">        final ASN1EncodableVector v2 = new ASN1EncodableVector();</span>
<span class="fc" id="L59">        v2.add(derPrefix);</span>
<span class="fc" id="L60">        v2.add(key);</span>
<span class="fc" id="L61">        final DERSequence derKey = new DERSequence(v2);</span>
<span class="fc" id="L62">        PemFileHelper.writePemFile(writer, derKey.getEncoded(), ASN1Identifiers.PUBLIC_KEY_DER_HEADER);</span>
<span class="fc" id="L63">    }</span>

    @Override
    public Boolean verify(final byte[] message, final byte[] signature) throws GeneralSecurityException {
        //TODO: Double check the issue the getV(), for now we are trying with both (27 and 28)
<span class="fc" id="L68">        final SignatureData signatureData1 = new SignatureData(</span>
                (byte) 27,
<span class="fc" id="L70">                Arrays.copyOfRange(signature, 0, 32),</span>
<span class="fc" id="L71">                Arrays.copyOfRange(signature, 32, 64));</span>
<span class="fc" id="L72">        final BigInteger derivedKey1 = Sign.signedMessageHashToKey(Hash.sha256(message), signatureData1);</span>
<span class="fc" id="L73">        final SignatureData signatureData2 = new SignatureData(</span>
                (byte) 28,
<span class="fc" id="L75">                Arrays.copyOfRange(signature, 0, 32),</span>
<span class="fc" id="L76">                Arrays.copyOfRange(signature, 32, 64));</span>
<span class="fc" id="L77">        final BigInteger derivedKey2 = Sign.signedMessageHashToKey(Hash.sha256(message), signatureData2);</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        return Arrays.equals(Secp256k1PublicKey.getShortKey(derivedKey1.toByteArray()), getKey()) ||</span>
<span class="pc bnc" id="L79" title="All 2 branches missed.">                Arrays.equals(Secp256k1PublicKey.getShortKey(derivedKey2.toByteArray()), getKey());</span>
    }

    /**
     * Gets a short key
     *
     * @param key the key as a byte array
     * @return short key as byte array
     */
    public static byte[] getShortKey(final byte[] key) {
<span class="fc" id="L89">        final BigInteger pubKey = new BigInteger(key);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        final String pubKeyPrefix = pubKey.testBit(0) ? &quot;03&quot; : &quot;02&quot;;</span>
<span class="fc" id="L91">        final byte[] pubKeyBytes = Arrays.copyOfRange(key, 0, 32);</span>
<span class="fc" id="L92">        return Hex.decode(pubKeyPrefix + Hex.encode(pubKeyBytes));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>